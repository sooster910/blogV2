---
layout: post
title:  "Integration Testing with jest & puppeteer[1]"
description: 
tags: DataStructure/Algorithm JS  
---
* LinkedList 를 공부하며 남긴 글입니다. 오타가 있거나 설명이 잘못 되었다거나 조금 더 보충설명이 필요하시다고 생각되시면 댓글 남겨 주세요. 언제든지 환영입니다 😄

## 목차
 [1.puppeteer + Jest](#puppeteerjest)\
 [2. npm run test 실행환경 구축 ](#npm-run-test-실행환경-구축)\
 [3. headless chromium 테스트 코드로 오픈하기](#headless-chromium-테스트-코드로-오픈하기)\
 [4. beforeEach( ), afterEach( ) 이용하여 리팩토링](#drydont-repeat-yourself)\
 [5. Jest test case 작성](#test-case-작성)

## What is Singly Linked List?
 직역으로 서로 연결된 리스트이다. 주로 배열과 함께 비교가 된다. 그 이유는 배열도 자료를 저장하는 구조가 되고, 연결 리스트도 또한 자료를 저장하기 위해서 만든 자료구조에 해당한다. 이 둘의 장단점을 이용해 더 효율적으로 코딩을 할 수 있을 것이다.  
 배열 : 연속적인! 같은 자료형!들의 집합!이다.  
 장점: 1. 연속적이기 때문에, 데이터의 위치를 알기가 쉽다.  
 단점 : 메모리를 한꺼번에 만들어야 한기 때문에, 메모리 공간 낭비가 크다.  
 이러한 단점을 보완한 것이 Singly Linked List 이다.
 linked list 는 실행시간에 필요할 때 마다 동적으로 메모리를 생성 한다.(동적메모리로 만들어진다) 그럼 필요 할때 마다 만들어진 메모리들이 어떤 위치에 저장되는지 어떻게 알 수 있으며, 첫번째로 만들어진 메모리인지 두번째로 만들어진 메모리인지 어떻게 알 수 있을까?
 배열의 경우 시작점만 알면 그 나머지의 element 들을 쉽게 접근할 수 있다. 이런 데이터를 연결하기 위해 첫번째 데이터가 저장된 곳에, 추가적으로 두번째 데이터의 정보가 저장되어 있어야 한다.  
 

무엇을 연결? 노드들을 연결한다.  
얼마나? 제한이 없다.  
노드가 뭔가요?

head, tail , length property를 가지고 있다.
Linked List 는 노드로 이루어져있고, 이 각각의 노드들은 value그 노드의 값과 다음 노드를 가르키는 pointer 로 이루어져 있다.
Linked List 는 index 가 없다. 이 말은 즉, 5번 째 element의 값을 달라고 요구할 수 없다. Linked Lists는 Array와는 또 다른 특징을 가진 다른것임을 유추 할 수 있다. 
🚀  linked list 의 특징

- linked list는 배열과 같은 선형 자료 구조로서 데이터를 순서대로 저장하는 자료구조이다.
- 노드에 대한 레퍼런스를 저장해서 순서를 유지 .
- 하지만 메모리에는 연속적 이거나 순서대로 저장 되지는 않는다. 즉, 아무데나 저장될 수 있다.
- 포인터기반의 연결방식이다. (배열은 메모리공간기반의 연속방식)
- 삽입시 저장하려는 위치의 전 노드의 레퍼런스를 파라미터로 받아
- sinlgy와 dubly 리스트의 일반적인 경우 삽입 삭제 연산들은 파라미터로 노드를 받는다. 이 노드를 탐색하여서 삭제를 하는데 탐색하는데 걸리는 시간은 n-1 일것이고 , 삭제는 O(1), 결국 O(n-1+1)= O(n) 이걸린다.
- 단, 맨앞과 맨뒤의 경우는 O(1) 의 복잡도를 가진다. 그 이유는, head 노드와 tail 노드가 있기 때문에, 순회하지 않고 연결리스트로 한번에 접근가능하기 때문이다.
    - 링크드리스트의 사용이 효율적인 경우는 더블리 링크드 리스트에 주문접수가 들어오는 순서대로 저장하고 가장 앞에 (먼저 )있는 문의부터처리하고 지워야 할때
- 동적배열과 비교 :
    - 같은점 : 선형탐색방법 O(n)으로만 가능
    - 다른점 : 맨 앞에 데이터를 삽입할 경우, singly linked list 가 동적배열 보다 더 효율적이다. 그 이유는 , 배열은 맨앞에 삽입시 나머지 뒤에 있는 요소들이 한 인덱스씩 뒤로 밀려야한다. O(n)으 ㅣ시간

👌  doubly 와 singly 의 추가적 공간

- 추가적 공간 : data 이외의 저장공간, singly: next node 를 저장하는 공간 n-1 , doubly : noxt node, prev node 를 저장하는 공간  2n - 2
- 추가적 공간은 메모리에 실질적으로  doubly linked list 가 두배정도 메모리를 쓴다. 공간을 효율적으로 사용하고 싶을 땐 sinlgy linked list 사용!
- 보통 몇번째라는 개념이기보다는 당장의 이전의 값이나 다음의 값만 중요한 경우를 고려할 때 링크드 리스트를 사용해요. 아마 지하철도 그 예시가 될 거 같아요.